<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>åŠ‡ç…§æµ®æ°´å°ç·¨è¼¯å™¨ - GagaOOLala (beta)</title>
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/site.webmanifest">
    
    <!-- 1. JSZip & FileSaver -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    
    <!-- 2. SmartCrop (å‚™æ´å¼•æ“) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/smartcrop/2.0.3/smartcrop.min.js"></script>

    <!-- 3. Face-API.js (ä¸»å¼•æ“) -->
    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    
    <style>
        :root {
            --bg-color: #121212;
            --panel-bg: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00d2ff;
            --ai-face-color: #00ff88;   /* äººè‡‰åµæ¸¬æˆåŠŸ */
            --ai-smart-color: #d84bf7;  /* SmartCrop å‚™æ´ */
            --filter-color: #ffaa00;
            --danger-color: #ff4444;
            --border-color: #444;
        }

        * { box-sizing: border-box; }

        body {
            font-family: "Helvetica Neue", Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦å´ Sidebar */
        .sidebar {
            width: 360px;
            background: var(--panel-bg);
            padding: 20px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 20;
            transition: all 0.3s ease;
        }

        h1 { font-size: 1.2rem; margin: 0 0 5px 0; color: white; letter-spacing: 1px; }
        .subtitle { font-size: 0.8rem; color: #888; margin-bottom: 20px; }
         
        .ai-badge { 
            background: linear-gradient(45deg, #00d2ff, #d84bf7); 
            color: black; padding: 2px 6px; border-radius: 4px; font-weight: bold; font-size: 10px; margin-left: 5px;
        }

        
        .mode-indicator {
            font-size: 11px; padding: 4px 8px; border-radius: 4px; margin-bottom: 15px;
            background: #333; color: #aaa; text-align: center; border: 1px solid #444;
        }
        .mode-indicator.active-landscape { border-color: var(--accent-color); color: var(--accent-color); }
        .mode-indicator.active-portrait { border-color: #ff9800; color: #ff9800; }

        .control-group { margin-bottom: 20px; border-bottom: 1px solid #333; padding-bottom: 15px; }
        .control-group:last-child { border-bottom: none; }
        
        label { display: block; margin-bottom: 8px; font-size: 0.85rem; color: #bbb; }
        input[type="text"] {
            width: 100%; padding: 10px; border-radius: 4px; border: 1px solid #555; background: #2a2a2a; color: white; 
            font-size: 14px;
        }
        input[type="text"]::placeholder { color: #666; font-style: italic; }

        .file-btn {
            display: block; width: 100%; padding: 10px; background: #333; color: #ccc;
            text-align: center; border: 1px dashed #666; cursor: pointer; border-radius: 4px; margin-bottom: 5px;
            box-sizing: border-box;
        }
        .file-btn:hover { border-color: var(--accent-color); color: white; }
        input[type="file"] { display: none; }

        /* AI å¼•æ“åˆ‡æ›æŒ‰éˆ• */
        .engine-switch { display: flex; gap: 10px; margin-bottom: 5px; }
        .engine-btn {
            flex: 1; padding: 8px; border: 1px solid #444; background: #222; color: #888;
            border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .engine-btn.active {
            background: var(--accent-color); color: #000; border-color: var(--accent-color); font-weight: bold;
        }
        .engine-desc { font-size: 10px; margin-top: 2px; opacity: 0.8; font-weight: normal; }

        .slider-row { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 2px;}
        .slider-val { color: var(--accent-color); font-family: monospace; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--accent-color); margin: 5px 0 15px 0; }

        .action-area { margin-top: auto; padding-top: 20px; }
        .btn {
            width: 100%; padding: 12px; border: none; border-radius: 6px; 
            font-size: 14px; font-weight: bold; cursor: pointer; margin-bottom: 10px;
            transition: 0.2s; display: flex; justify-content: center; align-items: center; gap: 8px;
        }
        .btn-primary { background: var(--accent-color); color: #000; }
        .btn-primary:hover { background: #66e0ff; }
        .btn-secondary { background: #444; color: white; }
        .btn-secondary:hover { background: #555; }
        .btn-outline { background: transparent; border: 1px solid #555; color: #aaa; padding: 8px; font-size: 12px; margin-bottom: 15px; }
        .btn-outline:hover { border-color: #888; color: white; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .footer-credit {
            text-align: center; font-size: 11px; color: #555; margin-top: 10px;
            border-top: 1px solid #333; padding-top: 15px; font-weight: 500;
        }

        /* å³å´ä¸»å€åŸŸ */
        .main-area {
            flex: 1; display: flex; flex-direction: column; background: #000; overflow: hidden;
        }

        .tabs { display: flex; background: #252525; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .tab {
            padding: 15px 20px; cursor: pointer; color: #888; font-weight: bold; transition: 0.2s; border-right: 1px solid #333; flex: 1; text-align: center;
            white-space: nowrap;
        }
        .tab.active { background: #000; color: var(--accent-color); border-top: 3px solid var(--accent-color); }
        .tab:hover:not(.active) { background: #2a2a2a; color: #ddd; }

        /* ç¶²æ ¼ç·¨è¼¯å€ */
        .editor-container {
            flex: 1; overflow-y: auto; padding: 20px;
            display: grid; gap: 25px; align-content: start;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
        }
        
        .editor-container.portrait-mode {
            grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
        }

        .edit-card {
            background: #1a1a1a; border: 1px solid #333; border-radius: 8px; overflow: hidden;
            display: flex; flex-direction: column; position: relative;
            transition: border 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .edit-card.selected { border: 1px solid var(--accent-color); }
        .edit-card.unselected { opacity: 0.7; }
        
        /* Canvas Wrapper */
        .canvas-wrapper {
            position: relative; 
            background: #000; 
            width: 100%;
            height: auto; 
            cursor: grab;
            overflow: hidden;
            touch-action: none; 
        }
        .canvas-wrapper:active { cursor: grabbing; }

        .canvas-wrapper canvas {
            display: block;
            width: 100%;
            height: auto; 
            object-fit: contain; 
        }

        /* AI æ¨™ç±¤æ¨£å¼ */
        .ai-badge-icon {
            background: #333; color: #ddd; border-radius: 4px; font-size: 10px; font-weight: bold;
            padding: 0 6px; height: 26px; display: flex; align-items: center; justify-content: center; gap: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5); cursor: default; border: 1px solid rgba(255,255,255,0.2);
        }
        .ai-badge-icon.face { background: linear-gradient(45deg, #006633, #00ff88); color: black; }
        .ai-badge-icon.smart { background: linear-gradient(45deg, #5500aa, #d84bf7); color: white; }

        /* å¡ç‰‡åº•éƒ¨æ§åˆ¶å€ */
        .card-controls { padding: 10px; background: #222; border-top: 1px solid #333; display: flex; flex-direction: column; gap: 8px;}
        .control-row { display: flex; align-items: center; gap: 8px; width: 100%; }
        .control-label { font-size: 11px; color: #888; min-width: 45px; display: flex; align-items: center; gap: 4px; }
        input[type=range] { margin: 0; flex: 1; height: 4px; }

        .color-btn {
            background: #333; border: 1px solid #555; color: #ccc; font-size: 11px; padding: 4px 8px; border-radius: 4px; cursor: pointer;
            transition: 0.2s; display: flex; align-items: center; gap: 4px; margin-left: auto;
            white-space: nowrap;
        }
        .color-btn:hover, .color-btn.active { background: var(--filter-color); color: black; border-color: var(--filter-color); }

        .filter-panel {
            background: #181818; padding: 8px; border-radius: 4px; margin-top: 5px;
            display: none; border: 1px solid #333;
        }
        .filter-panel.show { display: block; animation: fadeIn 0.2s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

        .card-info {
            padding: 8px 10px; background: #1a1a1a; font-size: 11px; color: #666; border-top: 1px solid #2a2a2a;
            white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
        }

        .card-tools {
            position: absolute; top: 0; left: 0; width: 100%; padding: 8px; box-sizing: border-box;
            display: flex; justify-content: space-between; z-index: 5;
            background: linear-gradient(to bottom, rgba(0,0,0,0.7), transparent);
            pointer-events: none; 
        }
        .tools-right { display: flex; gap: 5px; pointer-events: auto; align-items: center; }

        .checkbox-wrapper { pointer-events: auto; display: flex; align-items: center; cursor: pointer; }
        .custom-checkbox {
            width: 18px; height: 18px; border: 2px solid white; background: rgba(0,0,0,0.5); border-radius: 4px;
            display: flex; align-items: center; justify-content: center; transition: 0.2s;
        }
        .checkbox-wrapper.active .custom-checkbox { background: var(--accent-color); border-color: var(--accent-color); }
        .checkbox-wrapper.active .custom-checkbox::after { content: 'âœ”'; font-size: 12px; color: #000; font-weight: bold; }

        .icon-btn {
            background: rgba(0,0,0,0.5); border: 1px solid #777; color: #ddd; border-radius: 4px;
            width: 26px; height: 26px; display: flex; align-items: center; justify-content: center; cursor: pointer;
            font-size: 14px; transition: 0.2s;
        }
        .icon-btn:hover { background: #444; border-color: white; color: white; }
        .delete-btn:hover { background: var(--danger-color); border-color: var(--danger-color); }

        .empty-state {
            grid-column: 1 / -1; height: 100%; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #555; padding: 50px 0; text-align: center;
        }

        .loading-overlay {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 100;
            justify-content: center; align-items: center; flex-direction: column;
        }
        .spinner {
            border: 4px solid #333; border-top: 4px solid var(--accent-color);
            border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .loading-subtitle { color: #888; font-size: 12px; margin-top: 5px; }

        /* --- RWD éŸ¿æ‡‰å¼è¨­è¨ˆ --- */
        @media (max-width: 900px) {
            body { flex-direction: column; height: auto; overflow-y: auto; }
            .sidebar { width: 100%; height: auto; max-height: none; border-right: none; border-bottom: 1px solid var(--border-color); padding: 15px; }
            .main-area { height: auto; min-height: 500px; overflow: visible; }
            .editor-container { overflow-y: visible; padding: 15px; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); }
            .editor-container.portrait-mode { grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); }
            .file-btn { width: 100%; }
            .footer-credit { display: flex; align-items: center; justify-content: center; gap: 10px; padding-bottom: 0; }
            .footer-credit br { display: none; }
        }

        @media (max-width: 500px) {
            .editor-container { grid-template-columns: 1fr; }
            .editor-container.portrait-mode { grid-template-columns: 1fr 1fr; gap: 10px; }
            .tabs .tab { font-size: 14px; padding: 12px 5px; }
        }

    </style>
</head>
<body>

    <!-- å´é‚Šæ¬„ -->
    <div class="sidebar">
        <div>
            <h1>åŠ‡ç…§ç·¨è¼¯å™¨ <span class="ai-badge">Face-API</span></h1>
            <div class="subtitle">V8.5 (beta)</div>
            
            <div id="modeIndicator" class="mode-indicator active-landscape">ç›®å‰è¨­å®šæ¨¡å¼ï¼šæ©«å¼ (Landscape)</div>

            <div class="control-group">
                <label>ğŸ¤– AI æ§‹åœ–å¼•æ“</label>
                <div class="engine-switch">
                    <button id="btnEngineFace" class="engine-btn active">Face-API <span class="engine-desc">äººè‡‰å„ªå…ˆ (ç²¾æº–ä½†æ…¢)</span></button>
                    <button id="btnEngineSmart" class="engine-btn">SmartCrop <span class="engine-desc">è‰²å½©æ§‹åœ– (å¿«é€Ÿ)</span></button>
                </div>
            </div>

            <div class="control-group">
                <label style="color:white;">ğŸ“ å°ˆæ¡ˆ/å½±é›†ä»£ç¢¼ (å‘½åç”¨)</label>
                <input type="text" id="filenamePrefix" placeholder="ä¾‹å¦‚: If_The_World (ç•™ç©ºå‰‡ç”¨åŸæª”å)">
            </div>

            <div class="control-group">
                <label>1. ä¸Šå‚³ Logo (PNG)</label>
                <label for="logoInput" class="file-btn" id="logoLabel">é¸æ“‡ Logo</label>
                <input type="file" id="logoInput" accept="image/png, image/jpeg">
            </div>

            <div class="control-group">
                <label>2. ä¸Šå‚³åŠ‡ç…§</label>
                <label for="imageInput" class="file-btn">æ–°å¢åœ–ç‰‡</label>
                <input type="file" id="imageInput" multiple accept="image/*">
                
                <div style="display:flex; justify-content:space-between; margin-top:10px; align-items:center;">
                    <div style="font-size:12px; color:#aaa;">æ­¤æ¨¡å¼å·²é¸: <span id="selectedCount" style="color:var(--accent-color);">0</span> å¼µ</div>
                    <button id="toggleSelectBtn" class="btn-outline">å…¨é¸ / å–æ¶ˆ</button>
                </div>
            </div>

            <div class="control-group">
                <label>ç‰ˆæ¬Šæ–‡å­— <span style="font-size:10px; color:#888;">(å…§å®¹å…±ç”¨)</span></label>
                <input type="text" id="copyrightText" placeholder="ä¾‹å¦‚ï¼šÂ©2025 Love Begins in the World of If Production committeeãƒ»MBS">
                
                <div class="slider-row" style="margin-top:10px;">
                    <label>æ–‡å­—å¤§å° (<span id="textModeLabel" style="color:var(--accent-color)">æ©«å¼</span>)</label>
                    <span class="slider-val" id="fontSizeVal">1.2</span>
                </div>
                <input type="range" id="fontSizeScale" min="0.5" max="3.0" step="0.1" value="1.2">
            </div>

            <div class="control-group">
                <div class="slider-row"><label>Logo ç¸®æ”¾ (<span id="logoModeLabel" style="color:var(--accent-color)">æ©«å¼</span>)</label><span class="slider-val" id="logoScaleVal">50%</span></div>
                <input type="range" id="logoScale" min="10" max="80" value="50">
                
                <div class="slider-row"><label>Logo åº•éƒ¨è·é›¢</label><span class="slider-val" id="logoBottomVal">0%</span></div>
                <input type="range" id="logoBottom" min="0" max="20" value="0">
            </div>

            <div class="control-group">
                <div class="slider-row"><label>é»‘è‰²æ¼¸å±¤é«˜åº¦</label><span class="slider-val" id="gradHeightVal">25%</span></div>
                <input type="range" id="gradHeight" min="0" max="60" value="25">
                
                <div class="slider-row"><label>æ¼¸å±¤æ¿ƒåº¦</label><span class="slider-val" id="gradOpacityVal">0.7</span></div>
                <input type="range" id="gradOpacity" min="0" max="1" step="0.1" value="0.7">
            </div>
        </div>

        <div class="action-area">
            <button id="dlBtn" class="btn btn-primary" disabled>
                <span>â¬‡</span> ä¸‹è¼‰ç›®å‰æ¨¡å¼ (é¸å–é …ç›®)
            </button>
        </div>

        <div class="footer-credit">
            <img src="https://img.gagaoolala.com/assets/v2.1.1/img/ui/logo.png" alt="GagaOOLala Logo" width="120" height="26">
            <br>
            GagaOOLala è¨­è¨ˆéƒ¨é–‹ç™¼
        </div>
    </div>

    <!-- ä¸»å€åŸŸ -->
    <div class="main-area">
        <div class="tabs">
            <div class="tab active" data-mode="landscape">æ©«å¼ç·¨è¼¯å€ (1920 x 1080)</div>
            <div class="tab" data-mode="portrait">ç›´å¼ç·¨è¼¯å€ (1080 x 1350)</div>
        </div>

        <div class="editor-container" id="editorContainer">
            <div class="empty-state">
                <h2>å°šæœªè¼‰å…¥åŠ‡ç…§</h2>
                <p>è«‹å¾å·¦å´ä¸Šå‚³åœ–ç‰‡ï¼Œç³»çµ±å°‡è‡ªå‹•åµæ¸¬äººè‡‰èˆ‡æ§‹åœ–</p>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <div id="progressText" style="color:white; margin-top:15px; font-weight:bold;">è™•ç†ä¸­...</div>
        <div id="progressSub" class="loading-subtitle">æ­£åœ¨ä¸‹è¼‰ AI æ¨¡å‹</div>
    </div>

    <script>
        // --- Configuration ---
        const SIZE_LANDSCAPE = { w: 1920, h: 1080, name: 'Horizontal' };
        const SIZE_PORTRAIT = { w: 1080, h: 1350, name: 'Vertical' };
        const FACE_MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models';

        // --- State ---
        let globalSettings = {
            common: { copyrightText: "" },
            landscape: { logoScale: 50, logoBottom: 0, gradHeight: 25, gradOpacity: 0.7, fontSize: 1.2 },
            portrait: { logoScale: 50, logoBottom: 0, gradHeight: 25, gradOpacity: 0.7, fontSize: 1.2 }
        };

        let state = {
            mode: 'landscape',
            logo: null,
            sourceImages: [], 
            items: { landscape: [], portrait: [] },
            faceApiReady: false,
            aiEngine: 'face-api' // 'face-api' or 'smartcrop'
        };

        // --- Initialize Face-API ---
        async function initFaceAPI() {
            try {
                // Load TinyFaceDetector model
                await faceapi.nets.tinyFaceDetector.loadFromUri(FACE_MODEL_URL);
                state.faceApiReady = true;
                console.log("Face-API TinyFaceDetector loaded");
            } catch(e) {
                console.warn("Face-API Init Failed", e);
            }
            
            // Hide loading
            setTimeout(() => {
                if(document.getElementById('progressText').innerText === 'è™•ç†ä¸­...') return; 
                document.getElementById('loadingOverlay').style.display = 'none';
            }, 500);
        }

        initFaceAPI();

        // --- DOM Elements ---
        const els = {
            logoInput: document.getElementById('logoInput'),
            imageInput: document.getElementById('imageInput'),
            filenamePrefix: document.getElementById('filenamePrefix'),
            editorContainer: document.getElementById('editorContainer'),
            tabs: document.querySelectorAll('.tab'),
            selectedCount: document.getElementById('selectedCount'),
            toggleSelectBtn: document.getElementById('toggleSelectBtn'),
            dlBtn: document.getElementById('dlBtn'),
            loading: document.getElementById('loadingOverlay'),
            progress: document.getElementById('progressText'),
            progressSub: document.getElementById('progressSub'),
            modeIndicator: document.getElementById('modeIndicator'),
            textModeLabel: document.getElementById('textModeLabel'),
            logoModeLabel: document.getElementById('logoModeLabel'),
            logoScale: document.getElementById('logoScale'),
            logoBottom: document.getElementById('logoBottom'),
            gradHeight: document.getElementById('gradHeight'),
            gradOpacity: document.getElementById('gradOpacity'),
            copyright: document.getElementById('copyrightText'),
            fontSize: document.getElementById('fontSizeScale'),
            logoScaleVal: document.getElementById('logoScaleVal'),
            logoBottomVal: document.getElementById('logoBottomVal'),
            gradHeightVal: document.getElementById('gradHeightVal'),
            gradOpacityVal: document.getElementById('gradOpacityVal'),
            fontSizeVal: document.getElementById('fontSizeVal'),
            btnEngineFace: document.getElementById('btnEngineFace'),
            btnEngineSmart: document.getElementById('btnEngineSmart')
        };

        // --- Engine Switch ---
        els.btnEngineFace.addEventListener('click', () => setEngine('face-api'));
        els.btnEngineSmart.addEventListener('click', () => setEngine('smartcrop'));

        function setEngine(engine) {
            state.aiEngine = engine;
            if(engine === 'face-api') {
                els.btnEngineFace.classList.add('active');
                els.btnEngineSmart.classList.remove('active');
            } else {
                els.btnEngineSmart.classList.add('active');
                els.btnEngineFace.classList.remove('active');
            }
        }

        // --- Init & Listeners ---
        
        els.tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                els.tabs.forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.mode = tab.dataset.mode;
                if(state.mode === 'portrait') els.editorContainer.classList.add('portrait-mode');
                else els.editorContainer.classList.remove('portrait-mode');
                updateSidebarInputs(); 
                renderGrid();
            });
        });

        function updateSidebarInputs() {
            const s = globalSettings[state.mode];
            els.logoScale.value = s.logoScale; els.logoScaleVal.innerText = s.logoScale + '%';
            els.logoBottom.value = s.logoBottom; els.logoBottomVal.innerText = s.logoBottom + '%';
            els.gradHeight.value = s.gradHeight; els.gradHeightVal.innerText = s.gradHeight + '%';
            els.gradOpacity.value = s.gradOpacity; els.gradOpacityVal.innerText = s.gradOpacity;
            els.fontSize.value = s.fontSize; els.fontSizeVal.innerText = s.fontSize;
            els.copyright.value = globalSettings.common.copyrightText;
            const modeName = state.mode === 'landscape' ? 'æ©«å¼' : 'ç›´å¼';
            els.modeIndicator.innerText = `ç›®å‰è¨­å®šæ¨¡å¼ï¼š${modeName}`;
            els.modeIndicator.className = `mode-indicator active-${state.mode}`;
            els.textModeLabel.innerText = modeName;
            els.logoModeLabel.innerText = modeName;
            els.dlBtn.innerHTML = `<span>â¬‡</span> ä¸‹è¼‰${modeName} (é¸å–é …ç›®)`;
            updateUI();
        }

        els.copyright.addEventListener('input', (e) => {
            globalSettings.common.copyrightText = e.target.value;
            redrawAllCanvases();
        });

        const independentInputs = {
            'logoScale': 'logoScale', 'logoBottom': 'logoBottom', 
            'gradHeight': 'gradHeight', 'gradOpacity': 'gradOpacity', 
            'fontSizeScale': 'fontSize'
        };

        Object.keys(independentInputs).forEach(domId => {
            const el = document.getElementById(domId);
            const settingKey = independentInputs[domId];
            el.addEventListener('input', (e) => {
                globalSettings[state.mode][settingKey] = e.target.value;
                const valDisplay = document.getElementById(domId + 'Val');
                if(valDisplay) {
                    let suffix = (settingKey === 'gradOpacity' || settingKey === 'fontSize') ? '' : '%';
                    valDisplay.innerText = e.target.value + suffix;
                }
                redrawAllCanvases();
            });
        });

        els.logoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        state.logo = img;
                        document.getElementById('logoLabel').innerText = "âœ… " + file.name;
                        redrawAllCanvases();
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        els.imageInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files);
            if(files.length === 0) return;

            els.loading.style.display = 'flex';
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                els.progress.innerText = `æ­£åœ¨è¼‰å…¥ ${i+1}/${files.length}`;
                els.progressSub.innerText = state.aiEngine === 'face-api' ? "Face-API äººè‡‰åˆ†æä¸­..." : "SmartCrop å¿«é€Ÿåˆ†æä¸­...";

                const imgObj = await loadImage(file);
                const sourceId = 'src_' + Date.now() + Math.random();

                // Select Analysis Method based on user choice
                let analysisL, analysisP;

                if (state.aiEngine === 'face-api') {
                    analysisL = await analyzeHybridAI(imgObj, SIZE_LANDSCAPE.w, SIZE_LANDSCAPE.h);
                    analysisP = await analyzeHybridAI(imgObj, SIZE_PORTRAIT.w, SIZE_PORTRAIT.h);
                } else {
                    analysisL = await analyzeSmartCropOnly(imgObj, SIZE_LANDSCAPE.w, SIZE_LANDSCAPE.h);
                    analysisP = await analyzeSmartCropOnly(imgObj, SIZE_PORTRAIT.w, SIZE_PORTRAIT.h);
                }

                // 2. Create Source
                state.sourceImages.push({
                    id: sourceId,
                    file: file,
                    imgObj: imgObj,
                    adjustments: { brightness: 100, contrast: 100, saturation: 100 },
                    aiData: { landscape: analysisL.type, portrait: analysisP.type }
                });

                // 3. Create Items
                const lConfig = createConfigFromAI(imgObj, SIZE_LANDSCAPE, analysisL.crop);
                state.items.landscape.push({
                    id: 'item_' + Date.now() + Math.random() + '_l',
                    sourceId: sourceId,
                    cropConfig: lConfig,
                    selected: true
                });

                const pConfig = createConfigFromAI(imgObj, SIZE_PORTRAIT, analysisP.crop);
                state.items.portrait.push({
                    id: 'item_' + Date.now() + Math.random() + '_p',
                    sourceId: sourceId,
                    cropConfig: pConfig,
                    selected: true
                });
            }

            updateUI();
            renderGrid();
            els.loading.style.display = 'none';
        });

        els.toggleSelectBtn.addEventListener('click', () => {
            const currentList = state.items[state.mode];
            if(currentList.length === 0) return;
            const hasUnselected = currentList.some(item => !item.selected);
            currentList.forEach(item => item.selected = hasUnselected);
            updateUI();
            renderGrid(); 
        });

        // --- SmartCrop Only Wrapper ---
        async function analyzeSmartCropOnly(img, targetW, targetH) {
             try {
                const result = await smartcrop.crop(img, { width: targetW, height: targetH });
                return { type: 'smart', crop: result.topCrop };
            } catch (err) {
                return { type: 'none', crop: null };
            }
        }

        // --- Hybrid AI Logic ---
        
        async function analyzeHybridAI(img, targetW, targetH) {
            // 1. Try Face API
            if (state.faceApiReady) {
                try {
                    // Use TinyFaceDetector
                    const detections = await faceapi.detectAllFaces(img, new faceapi.TinyFaceDetectorOptions());
                    
                    if (detections && detections.length > 0) {
                        // Calculate bounding box of ALL faces
                        let minX = Infinity, minY = Infinity, maxX = 0, maxY = 0;
                        detections.forEach(d => {
                            const box = d.box;
                            if (box.x < minX) minX = box.x;
                            if (box.y < minY) minY = box.y;
                            if (box.x + box.width > maxX) maxX = box.x + box.width;
                            if (box.y + box.height > maxY) maxY = box.y + box.height;
                        });

                        // Return a "Face Center" crop object
                        // We construct a bounding box of the faces to use for centering
                        return { 
                            type: 'face', 
                            crop: { 
                                x: minX, 
                                y: minY, 
                                width: maxX - minX, 
                                height: maxY - minY 
                            } 
                        };
                    }
                } catch (e) {
                    console.warn("FaceAPI failed", e);
                }
            }

            // 2. Fallback: SmartCrop
            return await analyzeSmartCropOnly(img, targetW, targetH);
        }

        function createConfigFromAI(imgObj, targetSize, cropData) {
            const ratioSrc = imgObj.width / imgObj.height;
            const ratioTarget = targetSize.w / targetSize.h;
            let baseScale;

            if (ratioSrc > ratioTarget) baseScale = targetSize.h / imgObj.height;
            else baseScale = targetSize.w / imgObj.width;

            const config = {
                baseScale: baseScale, userScale: 1.0,
                origW: imgObj.width, origH: imgObj.height, x: 0, y: 0,
                aiDetected: !!cropData
            };

            if (cropData) {
                // cropData is {x, y, width, height} (Top-Left based)
                // Calculate center of the crop area (Face Group or SmartCrop)
                const cropCenterX = cropData.x + (cropData.width / 2);
                const cropCenterY = cropData.y + (cropData.height / 2);
                
                // We want this center point to be at the center of our canvas
                // Formula: CanvasCenter - (ImageCenter * Scale)
                config.x = (targetSize.w / 2) - (cropCenterX * baseScale);
                config.y = (targetSize.h / 2) - (cropCenterY * baseScale);
            } else {
                // Default center
                const scaledW = imgObj.width * baseScale;
                const scaledH = imgObj.height * baseScale;
                config.x = (targetSize.w - scaledW) / 2;
                config.y = (targetSize.h - scaledH) / 2;
            }

            recalculateBounds(config, targetSize.w, targetSize.h, false);
            return config;
        }

        function recalculateBounds(config, targetW, targetH, forceCenter = false) {
            const totalScale = config.baseScale * config.userScale;
            config.currentW = config.origW * totalScale;
            config.currentH = config.origH * totalScale;
            config.minX = targetW - config.currentW;
            config.minY = targetH - config.currentH;

            if (!forceCenter) {
                if (config.x < config.minX) config.x = config.minX;
                if (config.y < config.minY) config.y = config.minY;
                if (config.x > 0) config.x = 0;
                if (config.y > 0) config.y = 0;
            } else {
                config.x = (targetW - config.currentW) / 2;
                config.y = (targetH - config.currentH) / 2;
            }
        }

        // --- Rendering ---

        function updateUI() {
            const currentList = state.items[state.mode];
            const selectedCount = currentList.filter(item => item.selected).length;
            els.selectedCount.innerText = selectedCount;
            els.dlBtn.disabled = selectedCount === 0;
            els.toggleSelectBtn.disabled = currentList.length === 0;
        }

        function renderGrid() {
            els.editorContainer.innerHTML = '';
            if(state.items[state.mode].length === 0) { 
                els.editorContainer.innerHTML = `<div class="empty-state"><h2>å°šæœªè¼‰å…¥åŠ‡ç…§</h2><p>è«‹å¾å·¦å´ä¸Šå‚³åœ–ç‰‡</p></div>`;
                return;
            }

            const targetSize = state.mode === 'landscape' ? SIZE_LANDSCAPE : SIZE_PORTRAIT;
            
            state.items[state.mode].forEach((item) => {
                const source = state.sourceImages.find(s => s.id === item.sourceId);
                if(!source) return;

                const card = document.createElement('div');
                card.className = `edit-card ${item.selected ? 'selected' : 'unselected'}`;
                
                // Tools Overlay
                const tools = document.createElement('div');
                tools.className = 'card-tools';
                
                const cbWrapper = document.createElement('div');
                cbWrapper.className = `checkbox-wrapper ${item.selected ? 'active' : ''}`;
                cbWrapper.innerHTML = `<div class="custom-checkbox"></div>`;
                cbWrapper.onclick = (e) => { e.stopPropagation(); toggleImageSelection(item.id); };
                tools.appendChild(cbWrapper);

                const toolsRight = document.createElement('div');
                toolsRight.className = 'tools-right';
                
                // AI Badge
                const aiType = state.mode === 'landscape' ? source.aiData.landscape : source.aiData.portrait;
                if (aiType && aiType !== 'none') {
                    const aiBadge = document.createElement('div');
                    if (aiType === 'face') {
                        aiBadge.className = 'ai-badge-icon face';
                        aiBadge.innerHTML = 'äººè‡‰åµæ¸¬';
                    } else {
                        aiBadge.className = 'ai-badge-icon smart';
                        aiBadge.innerHTML = 'æ™ºæ…§æ§‹åœ–';
                    }
                    toolsRight.appendChild(aiBadge);
                }

                const dupBtn = document.createElement('div');
                dupBtn.className = 'icon-btn';
                dupBtn.innerHTML = 'â';
                dupBtn.title = "è¤‡è£½";
                dupBtn.onclick = (e) => { e.stopPropagation(); duplicateImage(item.id); };
                toolsRight.appendChild(dupBtn);

                const delBtn = document.createElement('div');
                delBtn.className = 'icon-btn delete-btn';
                delBtn.innerHTML = 'âœ•';
                delBtn.onclick = (e) => { e.stopPropagation(); removeImage(item.id); };
                toolsRight.appendChild(delBtn);

                tools.appendChild(toolsRight);
                card.appendChild(tools);

                // Canvas
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';
                
                const previewScale = 0.25; 
                const uiW = targetSize.w * previewScale;
                const uiH = targetSize.h * previewScale;

                const canvas = document.createElement('canvas');
                canvas.width = uiW;
                canvas.height = uiH;
                canvas.dataset.itemId = item.id;
                
                setupDrag(canvas, item, previewScale);
                wrapper.appendChild(canvas);
                
                // Controls
                const controls = document.createElement('div');
                controls.className = 'card-controls';
                
                const row1 = document.createElement('div');
                row1.className = 'control-row';
                row1.innerHTML = `<div class="control-label">ğŸ” ç¸®æ”¾</div>`;
                const zoomInput = document.createElement('input');
                zoomInput.type = 'range'; zoomInput.min = '1'; zoomInput.max = '3'; zoomInput.step = '0.01'; zoomInput.value = item.cropConfig.userScale;
                zoomInput.addEventListener('input', (e) => {
                    item.cropConfig.userScale = parseFloat(e.target.value);
                    recalculateBounds(item.cropConfig, targetSize.w, targetSize.h, false);
                    drawCanvas(canvas, item, source, previewScale);
                });
                row1.appendChild(zoomInput);

                const colorBtn = document.createElement('div');
                colorBtn.className = 'color-btn';
                colorBtn.innerHTML = `ğŸ¨ èª¿è‰²`;
                colorBtn.onclick = () => {
                    const panel = controls.querySelector('.filter-panel');
                    panel.classList.toggle('show');
                    colorBtn.classList.toggle('active');
                };
                row1.appendChild(colorBtn);
                controls.appendChild(row1);

                const filters = document.createElement('div');
                filters.className = 'filter-panel';
                
                const createFilterSlider = (label, key, icon) => {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    row.style.marginBottom = '5px';
                    row.innerHTML = `<div class="control-label">${icon} ${label}</div>`;
                    const input = document.createElement('input');
                    input.type = 'range'; input.min = '0'; input.max = '200'; input.step = '1'; input.value = source.adjustments[key];
                    input.addEventListener('input', (e) => {
                        source.adjustments[key] = parseInt(e.target.value);
                        redrawAllUsingSource(source.id);
                    });
                    row.appendChild(input);
                    return row;
                };

                filters.appendChild(createFilterSlider('äº®åº¦', 'brightness', 'â˜€'));
                filters.appendChild(createFilterSlider('å°æ¯”', 'contrast', 'â—‘'));
                filters.appendChild(createFilterSlider('é£½å’Œ', 'saturation', 'ğŸ­'));
                controls.appendChild(filters);

                const info = document.createElement('div');
                info.className = 'card-info';
                info.innerText = source.file.name;

                card.appendChild(wrapper);
                card.appendChild(controls);
                card.appendChild(info);
                els.editorContainer.appendChild(card);

                drawCanvas(canvas, item, source, previewScale);
            });
        }

        // --- Actions ---

        function toggleImageSelection(itemId) {
            const list = state.items[state.mode];
            const item = list.find(x => x.id === itemId);
            if(item) {
                item.selected = !item.selected;
                updateUI();
                renderGrid(); 
            }
        }

        function removeImage(itemId) {
            if(confirm('ç¢ºå®šè¦ç§»é™¤é€™å¼µåŠ‡ç…§å—ï¼Ÿ')) {
                state.items[state.mode] = state.items[state.mode].filter(x => x.id !== itemId);
                updateUI();
                renderGrid();
            }
        }

        function duplicateImage(itemId) {
            const list = state.items[state.mode];
            const index = list.findIndex(x => x.id === itemId);
            if (index === -1) return;
            const originalItem = list[index];
            const newItem = {
                id: 'item_' + Date.now() + Math.random(),
                sourceId: originalItem.sourceId,
                cropConfig: { ...originalItem.cropConfig }, 
                selected: originalItem.selected
            };
            list.splice(index + 1, 0, newItem);
            updateUI();
            renderGrid();
        }

        function setupDrag(canvas, item, uiScale) {
            let isDragging = false;
            let startX, startY, initialImgX, initialImgY;
            const onMouseDown = (e) => {
                isDragging = true;
                startX = e.clientX; startY = e.clientY;
                initialImgX = item.cropConfig.x;
                initialImgY = item.cropConfig.y;
                canvas.parentElement.style.cursor = 'grabbing';
            };
            const onMouseMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const visualScaleX = canvas.width / rect.width;
                const visualScaleY = canvas.height / rect.height;
                const deltaX = (e.clientX - startX) * visualScaleX * 1.2; 
                const deltaY = (e.clientY - startY) * visualScaleY * 1.2;
                let newX = initialImgX + deltaX; let newY = initialImgY + deltaY;
                const config = item.cropConfig;
                if (newX > 0) newX = 0;
                if (newX < config.minX) newX = config.minX;
                if (newY > 0) newY = 0;
                if (newY < config.minY) newY = config.minY;
                config.x = newX; config.y = newY;
                const source = state.sourceImages.find(s => s.id === item.sourceId);
                if(source) drawCanvas(canvas, item, source, uiScale);
            };
            const onMouseUp = () => { isDragging = false; canvas.parentElement.style.cursor = 'grab'; };
            canvas.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove); 
            window.addEventListener('mouseup', onMouseUp);
        }

        function redrawAllUsingSource(sourceId) {
            const canvases = els.editorContainer.querySelectorAll('canvas');
            canvases.forEach(cvs => {
                const itemId = cvs.dataset.itemId;
                const list = state.items[state.mode];
                const item = list.find(x => x.id === itemId);
                if(item && item.sourceId === sourceId) {
                    const source = state.sourceImages.find(s => s.id === sourceId);
                    drawCanvas(cvs, item, source, 0.25);
                }
            });
        }

        function redrawAllCanvases() {
            const canvases = els.editorContainer.querySelectorAll('canvas');
            canvases.forEach(cvs => {
                const itemId = cvs.dataset.itemId;
                const list = state.items[state.mode];
                const item = list.find(x => x.id === itemId);
                if(item) {
                    const source = state.sourceImages.find(s => s.id === item.sourceId);
                    if(source) drawCanvas(cvs, item, source, 0.25);
                }
            });
        }

        function drawCanvas(canvas, item, source, scaleFactor) {
            const ctx = canvas.getContext('2d');
            const targetW = canvas.width;
            const targetH = canvas.height;
            ctx.clearRect(0, 0, targetW, targetH);
            ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';

            const config = item.cropConfig;
            const settings = globalSettings[state.mode]; 
            const sharedText = globalSettings.common.copyrightText; 

            ctx.save();
            const adj = source.adjustments;
            if (adj) {
                ctx.filter = `brightness(${adj.brightness}%) contrast(${adj.contrast}%) saturate(${adj.saturation}%)`;
            }
            ctx.drawImage(source.imgObj, config.x * scaleFactor, config.y * scaleFactor, config.currentW * scaleFactor, config.currentH * scaleFactor);
            ctx.restore();

            const gHeightPercent = parseInt(settings.gradHeight) / 100;
            if (gHeightPercent > 0) {
                const gHeight = targetH * gHeightPercent;
                const opacity = settings.gradOpacity;
                const gradient = ctx.createLinearGradient(0, targetH - gHeight, 0, targetH);
                gradient.addColorStop(0, "rgba(0,0,0,0)");
                gradient.addColorStop(1, `rgba(0,0,0,${opacity})`);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, targetH - gHeight, targetW, gHeight);
            }

            if (state.logo) {
                const logoScaleP = parseInt(settings.logoScale) / 100;
                const logoBottomP = parseInt(settings.logoBottom) / 100;
                const drawLogoW = targetW * logoScaleP;
                const drawLogoH = drawLogoW * (state.logo.height / state.logo.width);
                const logoX = (targetW - drawLogoW) / 2;
                const logoY = targetH - drawLogoH - (targetH * logoBottomP);
                ctx.drawImage(state.logo, logoX, logoY, drawLogoW, drawLogoH);
            }

            if (sharedText) {
                const fontSizeBase = targetH * 0.012; 
                const fontSize = fontSizeBase * parseFloat(settings.fontSize);
                ctx.font = `${fontSize}px "Helvetica Neue", Arial, sans-serif`;
                ctx.fillStyle = "rgba(255,255,255,0.9)";
                ctx.textAlign = "right"; ctx.textBaseline = "bottom";
                ctx.shadowColor = "rgba(0,0,0,0.8)"; ctx.shadowBlur = 2; ctx.shadowOffsetX = 1; ctx.shadowOffsetY = 1;
                const marginX = targetW * 0.02; const marginY = targetH * 0.015; 
                ctx.fillText(sharedText, targetW - marginX, targetH - marginY);
            }
        }

        function loadImage(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => resolve(img);
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            });
        }

        function drawHighRes(item, mode) {
            const size = mode === 'landscape' ? SIZE_LANDSCAPE : SIZE_PORTRAIT;
            const canvas = document.createElement('canvas');
            canvas.width = size.w;
            canvas.height = size.h;
            const source = state.sourceImages.find(s => s.id === item.sourceId);
            drawCanvas(canvas, item, source, 1);
            return canvas;
        }

        els.dlBtn.addEventListener('click', () => {
            const targetMode = state.mode;
            const currentList = state.items[targetMode];
            const selectedItems = currentList.filter(img => img.selected);
            if(selectedItems.length === 0) { alert("è«‹è‡³å°‘é¸å–ä¸€å¼µç…§ç‰‡"); return; }
            els.loading.style.display = 'flex';
            els.progressSub.innerText = "æ­£åœ¨ç”¢ç”Ÿé«˜è§£æåº¦æª”æ¡ˆ...";
            const zip = new JSZip();
            const prefixInput = els.filenamePrefix.value.trim();
            const folderName = targetMode === 'landscape' ? "Horizontal_1920" : "Vertical_1080";
            const folder = zip.folder(folderName);
            (async () => {
                for (let i = 0; i < selectedItems.length; i++) {
                    const item = selectedItems[i];
                    const source = state.sourceImages.find(s => s.id === item.sourceId);
                    els.progress.innerText = `æ­£åœ¨è™•ç† ${i+1}/${selectedItems.length}...`;
                    const canvas = drawHighRes(item, targetMode);
                    const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.95));
                    let filename;
                    if (prefixInput) {
                        const seq = (i + 1).toString().padStart(3, '0');
                        filename = `${prefixInput}_${seq}.jpg`;
                    } else {
                        const siblings = selectedItems.filter(it => {
                            const s = state.sourceImages.find(src => src.id === it.sourceId);
                            return s.file.name === source.file.name;
                        });
                        let copySuffix = "";
                        if (siblings.length > 1) {
                             const copyIndex = siblings.indexOf(item) + 1;
                             copySuffix = `_v${copyIndex}`;
                        }
                        const suffix = targetMode === 'landscape' ? '_1920x1080' : '_1080x1350';
                        filename = source.file.name.replace(/\.[^/.]+$/, "") + copySuffix + suffix + ".jpg";
                    }
                    folder.file(filename, blob);
                }
                els.progress.innerText = "æ‰“åŒ…å£“ç¸®ä¸­...";
                const zipName = prefixInput ? `${prefixInput}_${targetMode}.zip` : `Watermarked_${targetMode}.zip`;
                zip.generateAsync({type:"blob"}).then(function(content) {
                    saveAs(content, zipName);
                    els.loading.style.display = 'none';
                });
            })();
        });

    </script>
</body>
</html>
